\chapter{UPPAAL model}\label{ch:uppaalmodel}
In order to decide upon a factory configuration in a given case, we must be able to evaluate configurations against each other. However, physcially setting up configurations to compare them is in no way practical. Instead we choose to simulate individual factory configurations and virtually compare them. For simulation we need an abstract model of the modular factory and the items that are processed by it. With such a model in place, we should be able to simulate a specific set of items being produced on a specific configuration. In addition we would like to get the best schedule for producing a set of items on a configuration. A schedule is a sequence of actions, instructing how to go from having no items, to having produced all items. Comparing schedules between configurations producing the same items helps choose, which configuration should be used for production. A configuration schedule may also be used as a jumping off point for generating KLR code.

To model and simulate the modular factory system, we use the UPPAAL model-checker\cite{Larsen97uppaalin}. This is an integrated tool environment used for modeling, simulating and verifying real-time systems. It allows us to model our system using timed automata in a combined graphical and programatic manner. Once we have designed our model, we may use it to instansiate a configuration and a set of items. UPPAAL can then simulate the production of these items on the given configuration. In addition, the included UPPAAL model-checker allows us to query different properties about the setup. To us, the most interesting property is one of reachability; Is it possible to reach a state, where x amount of items have been produced? If this is the case, then UPPAAL may produce a shortest timed trace of actions needed to reach this state. This evaluates to the temporaly shortest schedule to follow, in order to produce the given items on the given configuration.

However, we are not only be interested in the temporally shortest schedule, but also the one using the least amount of resources. This implies that some actions taken during processing, should have some type of cost. Regular UPPAAL does not come with this functionality. In order to involve costs we instead use an offshoot of UPPAAL, known as UPPAAL CORA\cite{UPPAALCORA}. This program is very similar to regular UPPAAL, but it also allows for a global cost variable to be used, alongside the regular global clock. This variable is strictly non-decreasing. The cost can be increased either when an action is taken, or as a function of time, when waiting in a location. The model checker may explore the state space in a UPPAAL CORA model in a best-first manner. That is, it looks for a trace to the goal state with the smallest global cost value. In addition, UPPAAL Cora includes some meta heuristic variables, which can be used to reduce the state space.

UPPAAL and its offshoots have been used to model many different real-life systems, such as a lacquer\cite{so54514} and an industrial printer\cite{Igna2008}. From this research we take inspiration for our model. In these examples however, UPPAAL is used to model systems with only a single configuration. Our work differs in that we attempt to model a system of which there are many possible configurations, which need to be compared. Therefore we focus on keeping the module flexible and avoiding hard-coded values. Thus, many different configurations and items may be instantiated.

When modeling the real world, we need to take care to pick an appropriate abstraction level. Too high, and the model will not fit well with the real world. Too low and the model becomes very complex. The more complex a model is, the bigger the search space. This severly increases the runtime when searching for a best schedule. Therefore, we naturally aim to hit a sweet spot between abstraction and complexity.

In this chapter we will explain how we modelled configurations and items in UPPAAL Cora, so that we may simulate them. This will be a look at both the technical implementation, but also a discussion on when we have abstracted from the real world, and when we have not.  

\input{sections/uppaalmodel/recipe.tex}
\input{sections/uppaalmodel/module.tex}

%\section{Running UPPAAL CORA through Python}
%Having defined our model, we can now use UPPAAL to instantiate a specific factory configuration and generate a best cost trace. However, we are are interested in comparing several configurations and from those pick the one with the best performance. Manually instantiating each configuration and developing a trace would be very time consuming. Instead, we work with our UPPAAL CORA models in a programmatic manner. This way we may write scripts for generating configurations and for each of these configurations, we can use UPPAAL CORA to generate a trace. Through the script we can then use the generated traces to pick the best configuration.

%We choose to script in Python 3.5 as it very simple to work with and the majority of group members have some experience with it. Python is not known for its fast computation, but most of the execution load will lay upon UPPAAL CORA, so this is not a great concern. 

%Out of the box, UPPAAL CORA does not have an API, so that we may interact with it through Python. The actual model checker part of the UPPAAL CORA installation lies in the verifyta executable. This may be called through the terminal. It takes two arguments, an XML file describing the given configuration and a file containing property queries. Additional arguments may involve the type of search, what kind of trace to generate etc. After run, results are written to the terminal. 


%In order to model check a configuration using python, we must create both an XML and a query file. The query file is simple as it needs only one query that checks whether it is possible for all recipes to end up in the “done” state. The XML file is a bit more difficult to handle. UPPAAL saves all information about a given project in an XML file. This Includes templates, global variables and the system declaration. In our case we have a project that includes the templates as described in \cref{sec:DesignAndImplementationInUPPAALCORA}. We may now edit this XML file, so that it creates the configurations we want to do model checking on.

%Based on a specific optimization problem the global declaration and system declaration need to be edited. In the global declaration, we must edit the amount of modules, worktypes and recipies present for the problem. These amounts are used to declare the correct channels and user defined types. In the system declaration, we must instantiate the recipes that need to be worked on, as well as a single instance of both the remover and the coster. For each specific factory configuration we then edit the system declaration further, by instantiating modules and connecting them according to the configuration specified. 


%A python script that handles a specific optimization problem should do the following. Take a set of recipes as input along with a set of modules. Generate a query file based on the number of recipies. Set up a base XML file according to the problem. Use the base to generate an XML file for each candidate, which may solve the problem. Each candidate should use only the modules specified in input. For each of the candidate XML files, run it on the verifyta executable along with the query file, making sure to set the options for generating the best cost trace. After each individual run, the script can extract the cost of the trace from the terminal output. Once all configurations have been run through we can compare the results. The configuration generating the lowest cost trace is picked as the solution. 


%With this overall execution plan we set up some complex questions which need to be answered. The pool of potential candidates is very large for any real problem, so a linear search is not very efficient. We need to restrict both what kind of candidate configurations we want to consider, in order to limit the search space. In addition we must find an efficient way to search through candidates. These questions will be tackled in the last two sections of this chapter. 
