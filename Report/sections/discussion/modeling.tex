\section{Modeling}\label{sec:modeling}
To rate configurations, which produce specific item orders, we developed a model in UPPAAL. With this model we can simulate items being produced by a factory. We may also generate the fastest timed trace, and from it extract the time it takes to produce the order. In this section, we will discuss what features we could have added to the model in addition to how it may be optimized further. We bookend the section by bringing up how the model compared to a real life factory. 

\subsection{Left Out Features}\label{ssec:LOFeatures}
In our current model, we may have a case, where the front element in a module's queue is waiting to be worked on by that module. At the same time, all items behind it may just need to pass through the module. On the actual CP Learning Factory setup, which we described in \cref{ssec:realcomparison}, they get around this by adding extra queues for items that need to be worked on by the module. In the case of the \textit{Robot Arm} module, it will guide items that it must work on onto an inner conveyour belt, where they will wait for processing. This ultimatly allows for other items to more easily pass through the module. Thus we have a real life case, which our model is not designed to handle. The issue with implementing the feature is that it will increase the global state space during search, as fewer items are stuck in queues and are free to transition around the configuration. 

We were not able to exactly generate the running example from \cref{fig:running-example} through our tabu search. This is in part because we have not described a transformation rule, which allows us to parallelize modules serially as is the case with \textit{Jigsaw} and \textit{Buzzsaw} in the aforementioned example. We did not do this, as our model does not reap the benefits of such a configuration. In order to keep down the state space, our model requires that an item may not pass through a module, which may work on it. This means that any wooden sword we create will be sawed by \textit{Jigsaw} and then pass right through \textit{Buzzsaw}. The issue with removing this condition is that our search may unecessarily branch further out into our configuration in search of another module, which may perform the same work.

Our model was not designed with our transformation rules in mind. We focused on keeping it as general as possible from the beginning. Yet we could get around the problem of parallelization increasing our state space, if we designed the model according to our parallelization rules. If we know that a serial parallization, as with \textit{Jigsaw} and \textit{Buzzsaw}, can happen, then we know that we should only look ahead by one neighbour, to see if another module may perform the work. Thus we can limit the amount of lookahead branching performed during search.   

\subsection{Optimization}
On the issue of optimization in general, we know that our state space begins to grow fast as more branches are added to the configuration. This results in our tabu search becoming slower and slower, as we try to rate configurations of a rising complexity. As the search requires many configurations to be simulated, we want to keep the time spent rating each configuration to a minimum. We realize that there is a balance to find between the number of features, we add to the model, and the state space. We also risk a slower execution time, if the solutions that lower the state space increase the size of our states.

To optimize the model, we could choose to make it less general and implement optimizing features, based on how our transformation rules create new configurations. It may also be beneficial to partition a configuration into several sub-configurations. Rating each smaller part would not take as long as running the whole configuration, as the state space increases exponentially as our configuration becomes more complex. The issue here is that it becomes more difficult to model the real world, as we must concern ourselves with how to handle modules in sub-configurations passsing items onto modules in other sub-configurations. 

\subsection{Comparison to a Real Factory}
In \cref{ssec:realcomparison} we looked into how modelled configurations fared compared to a real factory. For simple orders our model fared well, but we see that when orders become more complex, then the total execution time of orders begins drifting apart. In our case, the drift may be because we have not modeled how items may block each other on the inside the modules. We observed that this happend when items had to leave the \textit{Robot Arm} module's work queue. We must also remember that we only compare the total production time of orders, not how the actual factory and modelled configuration fared against each other during production.

The factory, which we compared against, was very simple. If the factory had some of the features mentioned in \cref{ssec:LOFeatures} our results would have been different. In addition, it would be interesting to compare against a real factory, which had a branching production similar to our generated. In spite of this, we are rather pleased with our results, as they indicate that our model can be used for some real life configurations.

