\section{Neighbour Functions}
In this section we describe, how we implement the transformation rules described in \cref{sec:math_rules} as neighbour functions. These neighbour functions are used by our tabu search for generating frontier neighbours as shown in \cref{code:psuedotabu}. The code for these functions can be found in the \textit{neighbour\_functions} directory and the code for solving conflicts in \textit{path\_placers.py}.


\subsection{Anti-Serialization}
For anti-serialization, we decided to implement the neighbour function in such a way that it retrieves all possible anti-serializations of a randomly chosen recipe on the main line. Meaning that whenever the transformation rules, $AS_0$, $AS_1$ and $AS_2$ could be applied on the main line for a chosen recipe, we did. We then return the resulting configurations as a set of neighbours.

We could have implemented the neighbour function for anti-serialization in such a way that it returned all possible uses of the anti-serialize transformation rules on all recipes. We however decided against this, as it could result in too many neighbours that our tabu search would have had to evaluate in one iteration.


\subsection{Parallelization}
For parallelization we designed the neighbour function such that we get all possible largest parallelization. This is done because we assume that if we can parallelize a set of modules on a line, then the neighbours that are a configuration with a subset of these modules parallelized to likely be worse. This might not always be the case, but it is an assumption we make, so that again our tabu search wont have to perform too many evaluation in a single iteration. 

We also only implemented the $Para_0$ rule, and not $Para_1$ and $Para_2$. $Para_1$ was not implemented due to how we handled items start location. As in our implementation an item can only start on a single module, and $Para_1$ requires that an item can start on multiple location. $Para_2$ was not implemented due to time constraints and for the gullible notion of symmetry.


\subsection{Swap}
For swap we implemented the neighbour function, such that we get all possible swaps. This can possible lead to a lot of neighbours having to be evaluated, if a configuration has a lot of free modules that are capable of being swapped. We can combat this by not making the swap transformations as likely as the other transformations in our tabu search.

\subsection{Conflicts}
For our conflict solving transformation rules, we implemented special functions that are capable of taking a neighbour which might have a conflict in it from one of the three previously mentioned neighbour functions, and then solve any present conflicts using the rules described in \cref{ssec:conflicts}. We used the $Push Around$ rule for fixing conflicts that occur due to anti-serialization and $Push Beneath$ for conflicts that occur due to parallelization.
 We always check the neighbours returned by our neighbour functions for conflicts and resolve them before we evaluate them. As we are not interested in evalutating and comparing neighbours with conflicts in them.
