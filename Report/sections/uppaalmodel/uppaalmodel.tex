\chapter{UPPAAL model}\label{ch:uppaalmodel}
In order to decide upon a factory configuration in a given case, we must be able to evaluate configurations against each other. However, physically setting up configurations to compare them is in no way practical. Instead we choose to simulate individual factory configurations and virtually compare them. For simulation we need an abstract model of the modular factory and the items that are processed by it. With such a model in place, we should be able to simulate a specific set of items being produced on a specific configuration. In addition we would like to get the best schedule for producing a set of items on a configuration. A schedule is a sequence of actions, instructing how to go from having no items, to having produced all items. Comparing schedules between configurations producing the same items aids in picking, which configuration should be used for production. A configuration schedule may also be used as a jumping-off point for generating KLR code.

To model and simulate the modular factory system, we use the UPPAAL model-checker\cite{Larsen97uppaalin}. This is an integrated development environment used for modelling, simulating and verifying real-time systems. It allows us to model our system using timed automata in a combined graphical and programmatic manner. Once we have designed our model, we may use it to instantiate a configuration and a set of items. UPPAAL can then simulate the production of these items on the given configuration. In addition, the included UPPAAL model-checker allows us to query different properties about the setup. To us, the most interesting property is one of reachability; Is it possible to reach a state, where x amount of items have been produced? If this is the case, then UPPAAL may produce a fastest timed trace of transitions needed to reach this state. This evaluates to the temporaly shortest schedule to follow, in order to produce the given items on the given configuration.

UPPAAL has been used to model many different real-life systems, such as a lacquer\cite{so54514} and an industrial printer\cite{Igna2008}. From this research we take inspiration for our model. In these examples however, UPPAAL is used to model systems with only a single configuration. Our work differs in that we attempt to model a system of which there are many possible configurations, which need to be compared. Therefore we focus on keeping the module flexible and avoiding hard-coded values. Thus, many different configurations and items may be instantiated.

When modelling the real world, we need to take care to pick an appropriate abstraction level. Too high, and the model will not fit well with the real world. Too low and the model becomes very complex. The more complex a model is, the more likely it is that the search space will be larger. This severely increases the runtime when searching for a best schedule. Therefore, we naturally aim to hit a sweet spot between abstraction and complexity.

In this chapter we will explain how we modelled configurations and items in UPPAAL, so that we may simulate them. This will be a look at both the technical implementation, but also a discussion on when we have abstracted from the real world, and when we have not.  

\input{sections/uppaalmodel/recipe.tex}
\input{sections/uppaalmodel/module.tex}
\input{sections/uppaalmodel/efficiency.tex}
\input{sections/uppaalmodel/evaluation.tex}