\chapter{UPPAAL model}\label{ch:uppaalmodel}
In this chapter, we describe, how we model modular factory configurations. In addition, we will explain, how we may rate a configuration by producing its fastest schedule through simulation. We want to be able to model and simulate configurations, so that we may compare the ratings of many different configurations. This would not be practical, if we had to set up each configuration physcially.

To model modular factories and simulate individual configurations, we use the UPPAAL model-checker\cite{Larsen97uppaalin}. This is an integrated development environment used for modelling, simulating and verifying real-time systems. It allows us to model our system using timed automata in a combined graphical and programmatic manner. Once we have designed our model, we may use it to instantiate a configuration and a set of items. UPPAAL can then simulate the production of these items on the given configuration. In addition, the model-checker included in UPPAAL, allows us to query different properties about the setup. To us, the most interesting property is one of reachability; \textit{Is it possible to reach a state, where all items in an order have been produced?} If this is the case, then UPPAAL may produce a fastest timed trace of transitions needed to reach this state. This sequence of system states evaluates to the fastest schedule for the given configration. Looking at the global clock of the final state in the trace gives us the time taken to execute the trace, and thus our configuration rating.

UPPAAL has been used to model many different real-life systems, such as a lacquer\cite{so54514} and an industrial printer\cite{Igna2008}. From this research we take inspiration for our model. In these examples however, UPPAAL is used to model systems with only a single configuration. Our work differs in that we attempt to model a system of which there are many possible configurations, which need to be compared. Therefore we focus on keeping the module flexible and avoiding hard-coded values. Thus, many different configurations and items may be instantiated.

When modelling the real world, we need to take care to pick an appropriate abstraction level. Too high, and the model will not fit well with the real world. Too low and the model becomes very complex. The more complex a model is, the more likely it is that the search space will be large. This severely increases the runtime, when searching for a best schedule. Therefore, we naturally aim to hit a sweet spot between abstraction and complexity.

In this chapter we will explain how we modelled configurations and items in UPPAAL, so that we may simulate production. This will be a look at both the technical implementation, but also a discussion on when we have abstracted from the real world, and when we have not. We will also extend the design decision made in \cref{sec:runningexample}. 

\input{sections/uppaalmodel/recipe.tex}
\input{sections/uppaalmodel/module.tex}
\input{sections/uppaalmodel/efficiency.tex}
\input{sections/uppaalmodel/evaluation.tex}