\chapter{Future Work}
In this chapter we will briefly go over some of the additions to our project that we would have like to accomplish in the future, if the time and the means are avaliable.

\section{Missing Implementations of Transformation Rules}
Perhaps the most pressing addition we could make, would be to implement the neighbour functions for $Para_1$ and $Para_2$. $Para_2$ should be relatively straight forward to implement, as there is no limitation stopping us from implementing it. $Para_1$ however would require us to redefine how place items onto a configuration. Currently items can only be added to a configuration at single starting module defined by their recipe. Implementing $Para_1$ requires that we find a way that allows items, which are made according to the same recipe, to have different starting modules. This could be solved by defining recipes, not with a starting module, but rather a start work. Then all modules that can perform this start work can have items ,made to that recipe, started on them.

\section{More Complex Transformation Rules}
We would have liked to describe more complex version of most of our transformation rules. Such as rules describing how we could anti-serialize a group of recipes at once. This would be useful, if we have a group of modules on which items made according to similar recipes are exclusivly worked.

Another more complex transformation rule could be allowing the parallel rules to create parallel branches, where we do not need a one to one correspondence between old modules and parallel modules. A good example was previously explained in \cref{sec:exp-tabu}, as the running example could parallelize out two modules that together could do all the work of a single module.

Lastly, we would like to implement a many to many swap transformation. That, similar to the complex parallelization rule explained above, allows us to swap modules that combined can do the work of whatever we wish to swap it with. Thus we could for example swap out a single module with a group of modules. 

\section{Better Heuristics for Tabu Search}
In the current implementation of our tabu search, we use memory rather ad hod, we would like to improve upon how we define and use both short and long term memory. Such that we in general would faster get better search result. One way we could possibly improve our search is that we for every configuration in long term memory also store the configuration chosen as its most optimal neighbour. This could be used to make sure that when we backtrack to a configuration from long term that we do not pick the same frontier.  


 



