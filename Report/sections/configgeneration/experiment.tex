\section{Generating the Running Example} \label{sec:exp-tabu}
In this section we will use our Tabu Search to generate a configuration that shares similarities to our running example, which can be seen in \cref{fig:running-example} and found in \cref{sec:runningexample}. We will use the same modules that are included in the running example to optimize an initial linear configuration. We will optimize the configuration such that it is able to produce items of the recipes described in \cref{fig:toy-recipes} as fast as possible. Then we will compare the configuration generated through our tabu search to the running example, which we made by hand.

\subsection{The Configuration Found by the Tabu Search}
As mentioned, our total set of modules for the tabu search will be the modules seen in \cref{fig:running-example}. Furthermore, we wish to optimize for an order asking to produce 3 items for each recipe described in \cref{fig:toy-recipes}. This is done in the hopes that 3 items of each recipe is enough to satiate the configuration enough, such that it encourages parallelization transformations. The resulting configuration of the tabu search can be seen in \cref{fig:tabu-config}.

\begin{figure}[H]
	\centering
	\includegraphics[width=.8\textwidth]{tabu-config.pdf}
	\caption{The configuration generated by our tabu search.}
	\label{fig:tabu-config}
\end{figure}

This configuration generated by our tabu search shows promise, as it has both utilized our anti-serialization and parallelization rules and is somewhat similar to the running example. 

We can see that it has used the anti-serialization rules because of the modules that uniquely only produce work for the doll recipe, are disconnected from the rest of the configuration. With the branches joining and splitting from the configuration at the common module \texttt{Painter}. In general, our tabu search has anti-serialized much in the same way as we did, when we made \cref{fig:running-example} by hand. The only exception is that we connected the modules \texttt{Sander} and \texttt{Wrapper} through a transport module, this being done so that rocking horse items may avoid going through \texttt{Painter}. We however have not made any type of transformation rule that would be allow the tabu search to do this. 

We can see that the search has used parallelization rules, as we have two paths from \texttt{Wood Loader} to \texttt{Connector} that both can do the work $saw$. This is different from the running example, as we there had the modules \texttt{Jigsaw} and \texttt{Buzzsaw} placed next to each other instead of parallel. In our UPPAAL model, an item can not pass through a module that can perform work on it. Thus we have not set up a transformation rule, which would place \textit{Jigsaw} and \textit{Buzzsaw} next to each other. If run on our model, all the work $saw$ would simply be done on the first module that the item enters, and the second would function merely as a glorified transport module.

A genuine advantage that the running example has over the generated configuration is that it parallelized the modules \texttt{Arm Giver} and \texttt{Leg Giver} from \texttt{Limb Giver}. This was not possible for our tabu search, as our implemented parallelization rules describe that when constructing a parallel line, each module in the new line must perform the active work of one specefic module in the old line. There is no mapping of one module to several in our parallization, as we otherwise see in the running example. This could be a beneficial rule to have implemented for our search.

Overall we are satisfied by the outcome that is our tabu search, as it seems capable, at least for this example, to heuristically find optimized solutions.
