\section{Formal transformation rules}
In this section we will describe how we may transformation a single line of modules in a configuration into other configurations which may be more efficient. In the first section we describe some basic mathematical sets that are used to describe the transformation rules in the following subsections.

\section{Common sets} 
In this section we will try to define a factory configuration using mathematical sets. The sets presented here are used to explain transformation rules in the following subsections.

Previously we presented recipes as acyclic dependency graphs. However at this level of abstraction we do not require the order in which works must be performed. Thus a recipe is simply defined as the set of works needed to be performed on it: 

\[recipe: \textit{A set of all work required to be done by a concrete recipe}\]

A factory configuration is made up of modules. Each module is defined by the following tuple:

\[module: \textit{(aW, mW, up, right, down, left, shadow)}\]

\noindent Where each element of the tuple represents the following:
\begin{itemize}
\item $aW$: The set of work that the module is actively doing.
\item $mW$: The set of work that the module can do.
\item $up,\, right,\, down,\, left$: Describes connections in one of four directions. Each can be either another module or Ã˜.
\item shadow: a boolean indicating whether there is a module placed above or below the module.
\end{itemize}

This definition closely resembles our previous definition of a module. Yet, we add $aW$ as to simplify the logic of our rules. 


In \cref{fig:trivial-example} we see that a configuration is made up of a single line of modules, while \cref{fig:running-example} is made up of three. As such we would like to define a factory configuration as a set of lines of modules, where the flow in each line is moving from left to right.

Let us define a line as a set of modules, which are ordered on the $\prec$ relation. This relation takes two modules $m_1$ and $m_2$ as arguments. It evaluates to true if there is a path from $m_1$ to $m_2$ in the actual factory configuration when we only traverse rightwards. $\prec$ is a total order, and we can thus define a line as a totally ordered set of modules, ordered using $\prec$:

\[line: \textit{A total ordered set of modules ordered on } \prec\]

Having defined recipes, modules and lines we choose to define a factory configuration with the following tuple. 

We now define a configuration as the following tuple:

\[configuration: (R, M, \Gamma)\]

Where:
\[R: \textit{The set of all recipes}\]
\[M: \textit{Set of all modules}\]
\[\Gamma: \textit{The set of all lines}\]


Furthermore we only want each $module$ to appear in a single $line$. To enforce this we set up the following rule for each $line$ $\gamma$, in $\Gamma$:
\[\texttt{if } \gamma \in \Gamma \texttt{ then } \forall m \in \gamma \land \forall \gamma ' \in \Gamma \land \gamma \neq \gamma ',\, m \notin \gamma ' \]


We also set up the following rule for each $module$ $m$ in $M$. This is done to ensure that the module can not perform work not within a recipe, and that the work which it actively performs should be a part of its total set of works:
\[\texttt{if } m \in M \texttt{ then } m.aW \subseteq m.mW \land m.mW \subseteq  \bigcup_{r\in R}r\] 

We also need to describe that not all available modules need to be a part of our factory configuration. There may exist free modules, which are not used, but may aid in the search for a higher throughput. First we describe the set of all modules used by a configuration, denoted $CM$:

\[CM = \{m \in \gamma | \gamma \in \Gamma \}\]

The set of free modules $FM$ is then given by:

\[FM = M \setminus CM \]


\subsection{Anti-serialization}
In \cref{fig:trivial-example} we see that some items will have to move through modules, where no work is performed on them. This will often happen if we have a line of modules, where more than one type of item is to be produced. We would like to describe a rule, which breaks the serial connection of a line of modules, making an off branch 


Given a specific recipe $r$, we define a special operation, $\bar{r}$, as as the union of the work that all recipes other than $r$ can do. 
\[\bar{r} = \bigcup_{r' \in R}r', \texttt{ if } r' \neq r\]
This is used for finding the set all modules within a line $\gamma$ where the recipe $r$ and some other recipe are being worked upon, denoted $K_{\gamma ,r}$. The set of all modules within $\gamma$ where $r$ isn't being worked upon, denoted $\alpha_{\gamma ,r}$. And the set of all modules within $\gamma$ where only $r$ is being worked on, denoted $beta_{\gamma ,r}$. 
\[K_{\gamma ,r} = \{m \in \gamma | \gamma \in \Gamma \land \exists \rho \in m.aW,\, \{\rho\} \subseteq r \land \{\rho\} \subseteq \bar{r} \land r \in R\}\]

\[\alpha_{\gamma ,r}  = \{m \in \gamma | \gamma \in \Gamma \land \forall \rho \in m.aW,\, \{\rho\} \nsubseteq r \land r \in R\}\]

\[\beta_{\gamma ,r}  = \{m \in \gamma | \gamma \in \Gamma \land \forall \rho \in m.aW,\, \{\rho\} \subseteq r \land \{\rho\} \nsubseteq \bar{r} \land r \in R\}\]


We define a set $KP_{\gamma ,r}$, such that it contains all pairs $(s, e)$ of $K_{\gamma ,r}$ modules where we can transverse from $s$ to $e$ without there being another $K_{\gamma, r}$ modules on the way.
\[KP_{\gamma ,r} = \{(s, e)| {s, e} \in K_{\gamma ,r} \times K_{\gamma ,r} \land s <_k  e\}\]
Where $s <_k e$ means that we can traverse right from $s$ to $e$ without seeing another $k_{\gamma, r}$ module. 

We define an operation, $M_{s,e}$, that given a pair start module $s$, and end module  $e$, where, we get all modules inbetween $s$ and $e$.
\[M_{s,e} = \{m | m \in \gamma \land \gamma \in \Gamma \land s \prec m \land m \prec e\}\]

We then define similar rules for finding all $\alpha$ and $\beta$ modules inbetween $s$ and $e$.
\[A_{s,e} = \{m |m \in M_{s,e} \land m \in \alpha\}\]
\[B_{s,e} = \{m |m \in M_{s,e} \land m \in \beta\}\]

\subsection{Parallel production}
If there are any free modules available that perform work required by your recipes, then it can often be advantages to parallelize certain parts of your configuration using these modules. In this section we will produce a rule for inserting in free modules in order to parallelize certain works. We begin by describing the some required sets.

First we describe the set of pairs, where the first element is a module in between the modules $s$ and $e$ and the second element is a free module that can do atleast the work that the first element is currently doing.
\[Map_{s, e} = \{(m, m')| m \in FM \land m' \in M_{s,e} \land m'.aW \subseteq m.mW\} \]


We then describe all sets of pairs that could be a possible parallel line for the modules between $s$ and $e$. Note that this set could be the empty set, as the modules needed for creating a possible line might not availabe in $FM$.
\[MapPaths_{s,e} = \{p \in {Map}_{s,e}^2 | (m,m') \in p \land (n,n') \in p \land |p| = |M_{s,e}| \land  \forall m': m' \neq n' \}\]

We define $s[1]$ as the operation that given a set of pairs $s$, gives the set of all the first elements of the pairs in $s$.
\[s[1] = \{m_1 | (m_1, m_2) \in s\}\]

Using this we define the set $P_{s,e}$ as $MapPaths_{s,e}$ but without the second element in each pair.

\[ P_{s,e} = \{p[1] | p \in MapPaths_{s,e}\}\]

We can then total order this $P_{s,e}$ using the relation $<_p$ which is defined as follows.

\[a <_{p} b = 
\left\{\begin{matrix}
tt \texttt{ if } x \prec y \land (x, a), (y, b) \in MapPaths_{s,e}\\
\texttt{else } ff
\end{matrix}\right.\]

Now that we have defined these sets we can now describe the rules for parallezing a line in a configuration. We begin with the base case, in which we parallelize everything inbetween two modules. A graphical representation of this can be seen in \cref{fig:para_se}. As shown by the figure, if we can find a $P_{s,e}$ we parallize it by connecting it with transport modules to $s$ and $e$. The order in which $P_{s,e}$ is placed is the total order $(P_{s,e},<_p)$. 

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{para_se.pdf}
\caption{Parallelization rule when you have both a start and end module}
\label{fig:para_se}
\end{figure}


We also have two other cases, one in which we have no end module, meaning that we will fork out a parallel line, and the case where we have no start, meaning we will join in a parallel line. A graph showing both of these cases can be seen respectively in \cref{fig:para_we} and \cref{fig:para_ws}. For the case without start we connect the last module in the total order $(P_{s,e}, <_p)$ to $e$, and for the case without end we connect $s$ to the first module the in the total order $(P_{s,e}, <_p)$.


\begin{figure}[h]
\centering
\includegraphics[width=0.3\textwidth]{para_we.pdf}
\caption{Parallelization rule when you do not have an end module}
\label{fig:para_we}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.3\textwidth]{para_ws.pdf}
\caption{Parallelization rule when you do not have a start module}
\label{fig:para_ws}
\end{figure}




\subsection{Swap}

