\section{Neighbour Functions}
In this section we describe, how we implement the transformation rules described in \cref{sec:math_rules} as neighbour functions. These neighbour functions are used by our tabu search for generating frontier neighbours as shown in \cref{code:psuedotabu}. The code for these functions can be found in the \textit{neighbour\_functions} directory and the code for solving conflicts in \textit{path\_placers.py}.


\subsection{Anti-Serialization}
For anti-serialization, we decided to implement the neighbour function in such a way that it retrieves all possible anti-serializations of a randomly chosen recipe on the main line. Meaning that whenever the transformation rules, $AS_0$, $AS_1$ and $AS_2$ could be applied on the main line for a chosen recipe, we did. We then return the resulting configurations as a set of neighbours. We also take care of shadowing and adding transport modules as brought up in \cref{ssec:restrictbranch}.

We could have implemented the neighbour function for anti-serialization in such a way that it returned all possible uses of the anti-serialize transformation rules on all recipes. We however decided against this, as it could result in too many neighbours that our tabu search would have had to evaluate in one iteration.


\subsection{Parallelization}
For parallelization, we designed the neighbour function such that we get all possible largest parallelizations. This is done. as we assume that if we can parallelize a set of modules on a line, then the neighbours that are a configuration with a subset of these modules parallelized is likely to be worse. This might not always be the case, but it is an assumption we make, so that our tabu search will not have to perform too many evaluation in a single iteration. 

Additionaly, we only implemented the $Para_0$ rule, and not $Para_1$ and $Para_2$. $Para_1$ was not implemented, as we can only give one start module to \textit{Recipe} objects. An item can only start on a single specefic module, and $Para_1$ requires that an item has the option to start in one of multiple location. $Para_2$ was not implemented due to time constraints and for the gullible notion of symmetry.


\subsection{Swap}
For swap, we implemented the neighbour function, such that we get all possible swaps. This can possible lead to a lot of neighbours having to be evaluated, if a configuration has a lot of free modules that are capable of being swapped. We can combat this, by not making the swap transformations as likely as the other transformations in our tabu search.


\subsection{Conflicts}
For our conflict solving transformation rules described in \cref{ssec:conflicts}, we implemented special functions that are capable of solving line conflicts, which a neighbour might have after being generated by either \textit{Anti-Serialization} or \textit{Parallelization}. A \textit{push\_around} function implements the $Push Around$ rule for fixing conflicts that occur due to anti-serialization. A \textit{push\_beneathe} function implements the  $Push Beneath$ rule for conflicts that occur due to parallelization. We always check the neighbours returned by our neighbour functions for conflicts and resolve them before we evaluate them. We are not interested in evalutating and comparing neighbours, which we can not physcially set up.

